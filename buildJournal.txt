2023.10.13:2024
    My first couple of challenges
    - figure out how to move the camera
    - figure out how to type in chat
    - figure out how to concede the game (so I don't have to wait for all the buildings to die)

    I think the easiest of these is

2023.10.13:2007
    Ok, we are learning a lot about rust
    - `let` to define variables => sure fine
    - variables are immutable by default, but can be made mutable by defining them `let mut <name>` => interesting
    - assiignment is like java-assignment => which is easier than lisp honestly
    - a `&` in an arg-var indicates a reference => nice
    - references are immutable by default, but may be made mutable by using `&mut` => nice

2023.10.13:1945
    *sad panda* - the adaptation to rust is not as cost-free as I had been hoping.  On the flip side, I think this also means I am going to get strict-typing (which would be nice).
    ref: https://doc.rust-lang.org/book/ch10-02-traits.html

2023.10.13:1915
    So I had this idea...  My mind is on like 2.5 tracks at the moment.
    1) picking up on the idea of `executors` I had before, I had some ideas for what might go into a "combat executor".
    2) Also, I need to find ways to get traction with rust & the project mechanics.  Getting comfortable with what the API offers as well as rust project structure
    2.5) Spinning off of the first & growing out of the second: I don't want to try and build this thing fully formed, so I need to get a handle on what parts I am going to try and build first.

2023.10.10:2222
    Joined the discord.  Today I learned that replays are played by double-clicking them.  *shake head* it is the super obvious ones that kill ya.  Also *sad panda* - you need to log into battle net to watch, which feels --limiting.
    
    Also, confirmed that replays at "C:\Users\<un>\Documents\StarCraft II\Replays\Multiplayer" are the replays generated by the bot.  

    Final point, recived a code snip on how to move a camera...  I don't have API docs yet (to know all the actions I can take), but at least having a few words to try and master seems like a reasonable thing to start with.

    The code snip is also in C# (b/c life is all about adaptation I guess)
    ```
    CameraAction = new SC2Action
                    {
                        ActionRaw = new ActionRaw
                        {
                            CameraMove = new ActionRawCameraMove()
                            {
                                CenterWorldSpace = position
                            }
                        }
                    };
    ```
    Guessing here: SC2Action, ActionRaw, & ActionRawCameraMove are all object types; and CenterWorldSpace is an attribute representing the map co-ordinates the screen is centered on?

    ref: github.com/UltraMachine/rust-sc2


2023.10.10:0814
    So I am working my way down the abstraction-mountain: I have this idea of "Pillers" & their "Managers", each characterized by their area of responsibility; logically, I know that at the bottom of this mountain I am going to need to arrive at units + buildings, as these are fundamentally the means by which I interact with the game-state; but the question then becomes, "are managers the thing directly responsible for bossing units/buildings around, or is their some intermediary abstraction?"; my instinct tells me there is (at least) one more intermediary step (working title "executor") which is given fairly broad instructions ("take XYZ base") and is responsible for operationalizing those instructions into individual unit-actions.  
    IE
        - (maybe?) request vision over the area to see if their are any enemy scouts / harrasers (ie hellions/zelots)
        - (maybe?) request detection over the area to see if their are any blockers (ie burrowed zerglings)
        - (maybe?) request a military sweep over the area to clear out the above
        - (maybe?) request extension of creep to connect with existing bases
        - request worker (for hatch) + (maybe?) workers for gas
        - move workers into position
        - request minerals for structures
        - build structures
        - (maybe?) req HomeGuard units for defense/detection while building
        - (maybe?) req spores/spines for defense
        - (maybe?) req spores for detection
        - (maybe?) req creep out to some radius for vision/defense

        => and, once all of this is done, we still need to
        - saturate mining for minerals / gas
        - (probably?) co-locate queen for injects
        - (mayybe?) co-locate HomeGuard for standing defense/detection
        ...but all of these (at least to my eye) fall outside the zone-of-responsibility of the "base initialization executor"
        <meta-thought: interesting, w/out quite realizing-it/meaning-to I seem to have started thinking of executors as "methods".  There is something to be said for this as a design principal.  Pillers/Managers are stateful (in the sense that they are long-term owners of units/resources) and function like "contexts", while executors are stateless (in the sense that they are short-lived and only "lease" units/resources from their contexts) and organized around a discrete + measureable outcome/>


2023.10.10:0655
    So I had a couple more ideas for "low hanging fruit"
    1) Easter Eggs:  feature-wise, this would be a collections of triggers & barks.  So, for instance, the first time my app saw stim used it would type in chat "dont do drugs kids"; or the first time it saw an oracle it would chat "go back to delphi"; etc.  Obviously the whole thing should be disable-able w/ a single feature-flag, as the real utility is to have a mechanism to observe / debug the event system.

    2) Cinematographer: tl;dr -> I want to have a module/feature (probably again with a feature flag) which manipulates the camera in order to automagically observe the game (in the caster/observer sense of the word).
        Intent.1: On one level, as someone who enjoys watching SC2, this feels like an opportunity to help independent caster's (which in turn should positively feed back into the sport w/ increased visibility).  Along those same lines, this would also be good marketing for my program w/in such spaces (even if/when my results might not be the best); winning through hearts-and-minds and all that *grin*.
        Intent.2: In the near term though, this would primarily be used as a debugging/observibility tool.  As I will get into next, I have been thinking about combat in a much more map-centric way (as opposed to a unit-centric approach, which I am under the impression currently predominates); as such getting they system to manipulate the camera would be very helpful for debugging issues around how it is reading/understanding the map.  

    3) Shift + click map-drawing: Something I have seen winterstarcraft do is, when sending a worker down to the natural to expand, he shift-queues attack-moves such that the worker's projected-path draws a red heart around the build location.  As a supplament/alternative to camera-controls, this is another way the system could have of communicating map locations (and possibly intent, based on the patterns of clicks).


2023.10.09:2221
    *yay* - I sucessfully followed instructions!!! (*grin*, and more importantly, it workeed).

    Some ideas for easy initial wins

    - see if I can put in some logic which concedes if I don't have any workers + have a "sacrificee all workers" command; mostly just so I don't have wait for the opponent to come over and kill all my buildings.

    - I was watching someone (prob either Sajuuk || sentdex) talk about how they were running into an issue where they issue a command for some action on frame.0, but they don't actually see the action start to take place until frame.2.  This obviously causes an issue if, on frame.1, your app is looking at basically the same game state as frame.0 & running basically the same code => so it tries to re-initiate the action again (potentially setting up conflicts with the frame.0 attempt).  The way that person solved it was just to take no action on alternating frames.  However, since I am planning on putting a fair bit of logic into this (another reason why I wanted to do rust over python), I could use this lag to essentially have the program do "macro cycles" --at the top level have a switch based on the modulo of the frame number as a way of breaking up which of my pillers is acting on any given frame.
    -- thinking out loud, this might cause an issue where; if we have an ajudication every round, requests from off-set pillers would never be balanced against each other.  So it might need to be broken up into
        micro-planning & independent-action 
        macro-planning & independent-action 
        ajudication 
        micro-fulfillment 
        macro-fulfillment
        loop
    ...on the one hand, this ensures that there is at least 1 frame between an action and when that manager gets to go again, but maybe this is too much? (realistically I need data to see where the load is)

       alt.idea, it makes a certain amount of sense that independent-actions should be faster/more responsive than integrated actions, so what if
       - micro A [req & independent action]
       - macro A [req & independent action]
       - micro B [req & independent action]
       - macro B [req & independent action]
       - Ajudication & req fulfillment AB
       - <skip to ensure fulfilled req are visible>
       - loop

    - Another somewhat free-floating idea came from watching sentdex jury-rig his bot into a ML trainer.  Having feedback mechanisms baked in from the start would be easy/low-cost now & could be useful later (if I get to that stage)


2023.10.09:2213
    Lol - life is hard, I spent all together way too long trying to figure out how to make visual studio to sv on loss of focus (and I'm still not sure I got it)

    Also, *sad panda*, it looks liike ultra-machine has theirs working in linux (*grin* while I am over here fighting with a windows VM - lol) *sad trombone* --it saves when I flip to the web-browser, but not when flipping between files; *sigh*

2023.10.09:2159
    Now, to try and reclaim the hello-world heights I did w/ python; this time in rust.

    All honor to https://github.com/UltraMachine/rust-sc2 for putting this together, lets see if I can get it to work :-P

2023.10.09:2125
    So, I decided I really wasn't a huge fan of the python...
    But they have a Rust option, which I have also never worked in before --but it kind of looks like clojure and so I feel much more comfortable.

    Fun fact, they brand themselves as "Rustaceans" (pronounced like crustacean), and their mascot is a crab called Ferris (alluding to ferrous, ie containing iron, that which rusts).
    Keeping with this spirit, I thought I wouold name my bot "fairy-day".  Primarily this is an omage to Michael Farady, but the playful spelling is also a tip-of-the-hat to Dael Kingsmill.

    Useful commands to remeber
        ref: https://doc.rust-lang.org/cargo/index.html
    Scafold New proj
        $ cargo new <proj>
    Running (from root)
        $ cargo run
    Build (which I think in this context is more like `lein deps` rather than `java compile`)
        $ cargo build
    Run Tests -> Note: rust proj maybe have an odd test layout w/ unit-tests in src/ and integrations in test/
        $ cargo tests
        $ cargo tests <filter on name-string, regex?>

2023.10.08:2010
    So this is most likely over-engineered, and it has all been daydreaming since I didn't have code in place to generate feedback.  Also, since thihs is a bit of a vanity project, I intend to be very indulgant to whatever ideas pop into my head --so that I can see where they go and whether they can hold up.

    As a mark in time, I want to document my current design ideas:

    As a starting point to describe this, I should say that in an SC2 game their are certain limitations placed upon a player; ie they can only know what is going on on the map w/in a "vision radius" of their game-pieces; in order to get more game-pieces they need to spend resources which they must first gather on the map; there is a hard & soft cap to how many units they may have active at once; etc.

    Therefore, it makes sense to me to decompose the overall task into 4 "pillers" which embody the competing priorities which an SC2 player is trying to balance during a game.

    _Economy_ => responsible for gathering resources from the map & producing two kinds of specialist-units; one which increase the soft-cap for units, and another which is a pre-cursor unit that is used to produce all other units (for those who play, it is a zerg bot, so overlords and larva).  

    _Technology_ => responsible for generating upgrades, which are durable benefits to categories of units for the rest of the game; also responsible for ensuring the existance of "pre-requisite structures" which allow for the transformation of pre-cursor units into more powerful / specialized units.

    _Scouting_ => responsible for maintaining as accurate as possible information as to the true state of the game. Since all of my bots information is knowable for it, this practically means gathering information on the opponent.  A non-exhaustive list of things I would like to track [unit & building locations; upgrades; army composition; resources gathered; (resources lost I should get for free, assuming my bot is the one that kills them)].

    -_Army_- (?) => This one is a bit tricky. In the SC2 parlance "army" generally refers to a players "fighting units", as distinct from their "economics units" (ie workers) and their "infrastructure" (ie buildings).  However, as I look at the problem it seems to be that *actually* there are 3 distinct responsibilities which army units can perform.  
        To explain I want to first make explicit something that might seem obvious to some: army-units generally have the characteristic that they can fight/fight-back, but workers & infrastructure (generally) lack this ability.  Therefore, when chosing how to use their army units players generally have a choice to either try and attack their opponent's army (which I will label a "symetric" attack) or attack their opponent's workers/infrastructure (which I will label an "asymetric" attack).  
        - The disadvantage of attacking symetrically is that the opponent will fight back & you will likely take losses / degrade your army as a result.
        - The advantage of attacking symetrically, is that if you can manage to win the fight (even in a degraded state) then there is nothing left stopping you wiping out the opponent's workers + infra; so it is basically a "checkmate" scenario.
        - Meanwhile, the advantage of attacking asymetrically is that workers/infra (usuallly) can't fight back; so practically speaking this type of attack can be done with just a fraction of your army & still noticably limit the opponent's future capability.
        - However, the disadvantage to attacking asymetrically is that (assuming both sides have grown at basically the same rate) the attacker's main-army will necessecarily be smaller and therefore at-risk of being overwhelmed in symetric engagement.  Furthermore, while a successful asyemtric attack can hurt an opponent's future potential, it does nothing to mitigate the here-and-now threat of their current army & so doesn't have the same "checkmating" potential.
        - Even so, if an opponent believes they will be asymetrically attacked they may pre-emptively split-off a fraction of their main army to effectively turn things back into a "mini" symetric engagement.  Which would, in turn, make their main army vulnerable to a symetric engagement.
        - And so we see the 3 core army responsibilities: symetric engagement; asymetric attack; asymetric defense.
    Originally, I had thought of making army a "synthetic manager" on top of the 3 army responsibilities ("manager" being my term for "thing which owns a single responsibility"), but after going through the description I think the idea of 3 managers on the same level as the others is a cleaner design.  So...
    
    _MainArmy_ => Responsible for symetric engagements.  When it thinks it can win, it should seek a fight.  When it thinks it will lose,
    it wants to run away in the open. If it is w/in range of workers/infra & it thinks it will lose, it should probably follow HomeGuard logic / have units re-assigned to the HomeGuard.
    
    _DisruptionArmy_ => Responsible for asymetric attacks.  Should use high-mobility to target opponent's workers & high-value infra.  Should be willing to engage army-groups which it can easily over-power, try to flee from fair fights, but turn and fight again if they are traped/doomed.
    
    _HomeGuard_ => Responsible for asymetric defense.  When opponent's forces (army-units?) are within range of a "sensitive area" (need to refine) & it thinks it can win, it should seek the fight.  When opponent's forces are within sensitive-area & it doesn't think it can win, it should 
        A) call for re-enforcements, 
        B) make a decision to either abandon or self-sacrifice
        -- abandon if the sensitive-area is worth less than home-guard in area; logic being, what is saved is more than what is lost.
        -- else self-sacrifice; logic being that even a losing fight will degrade the attacker's combat power & thereby limit the amount of damage taken while reenforcements are marshalled
        ** self-sacrifice could be refined further to capture the idea of "trading HP on a hatchery for time to marshal units", but it isn't obvious to me what that logic would be (hold just out of weapons range until hatch at 25% and then go?)


    *Adjudicator*
    - Pulling back from those (I guess now 6) pillers; it seems entirely plausible to me that the "managers" of any two given pillers might come into conflict with each other --after all, a resource spent in any one place is a resource not-spent everywhere else. To address this, there was an idea https://github.com/Guillaume-Docquier/Sajuuk-SC2 came up with that I want to shamelessly steal: put an "adjudicator" above all of the piller-managers.  
    -- Whenever a manager wants to take an action which impacts a shared-resource it submits a request to the adjudicator; and I should note here that in my vision units can only "belong-to"(ie receive instructions from) a single manager at a time, so transferring units between managers would also go through this process.
    -- As part of submitting a request, the manager also includes a weight of how important this request is to them
    -- Once received, the adjudicator then applies a discount to requests based on which piller is being given priority
    -- After discouunts are applied requests for the same action are consolidated, their priorities getting summed
    -- Finally, requests are sorted by priority and fullfilled/skipped based on resources
    ** it is unclear to me what should happen to skipped requests: (held onto, maybe with bonus priority next time? canceled and resumbit?)
    
    >> the "discount -> compact -> sort" dance feels like something that a slick-algo already does?
    >>> (assuming the thing operated on has a "provedence") the discount is just a loop + use a map to get discount factor
    >>> compact is basically a dupe check; whihch is a standard algo-problem
    >>> and then merge K sorted lists (which is also an algo problem)

    Other stuff for the "finding rages" stuff
        https://11011110.github.io/blog/2008/04/03/reweighting-graph-for.html
        https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm


2023.10.08:2003
    Lol - so I finally got the cannon-rush bot working, which means I can now start putting into code all the ideas I have had...
    Except the example I got working is in python, and I have no idea what I am doing in python, so now I am trying to figure out how to structure a python project :-P